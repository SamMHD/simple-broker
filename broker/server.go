// package broker serves a gRPC server which receives messages and logs them to desired destination using zerolog
// which is a zero allocation structured logger for Go like Uber's zap with a simpler API and even better performance.
// desired log destination is specified in the configuration file and it can be stdout, stderr or a file.
// after logging the message, it forwards the message to the destination service using gRPC in the background.
package broker

import (
	"context"
	"fmt"
	"net"
	"time"

	"github.com/SamMHD/simple-broker/pb"
	"github.com/SamMHD/simple-broker/util"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/reflection"
)

// Server is the gRPC server for the Broker
// it contains configurations, logger and destinationClient which is the gRPC client for the Destination service
// it also implements the BrokerServiceServer interface which is generated by protoc.
type Server struct {
	ctx           context.Context    // context for the server
	cancelContext context.CancelFunc // cancel function for the context

	config            util.Config                 // service configuration
	logger            zerolog.Logger              // zerolog logger
	grpcServer        *grpc.Server                // gRPC server
	destinationClient pb.DestinationServiceClient // gRPC client for the Destination service
	destinationConn   *grpc.ClientConn            // gRPC connection to the Destination service

	pb.UnimplementedBrokerServiceServer // required by the generated interface
}

// NewServer creates a new gRPC server for the Broker.
// it configures the logger and returns the server object and an error if any.
func NewServer(config util.Config) (*Server, error) {
	// create a new logger
	logger, err := newLogger(config.BrokerLogDestination)
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "broker").Msgf("failed to create logger: %s", err)
		return nil, err
	}

	ctx, cancel := context.WithCancel(context.Background())

	// create a new server object
	server := &Server{
		config:        config,
		logger:        logger,
		ctx:           ctx,
		cancelContext: cancel,
	}

	// return the server object
	return server, nil
}

// DialDestinationRPC dials the Destination gRPC server and creates a client for it.
// in case of an error, it returns the error.
func (server *Server) DialDestinationRPC() error {
	log.Info().Str("ser_name", "broker").Msg("Trying to dial Destination RPC...")

	// dial the destination service gRPC server
	var err error
	server.destinationConn, err = grpc.Dial(
		server.config.DestinationAddress,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(), grpc.WithTimeout(2*time.Second),
	)
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "broker").Msgf("failed to dial Destination RPC: %s", err)
		return err
	}

	// create a new client for the destination service
	server.destinationClient = pb.NewDestinationServiceClient(server.destinationConn)
	log.Info().Str("ser_name", "broker").Msg("Connection to Destination RPC established.")
	return nil
}

// StartGrpcServer starts the gRPC server for the Broker.
// it will block the current thread until the server is stopped.
// in case of an error, it returns the error and in case of peacefull shutdown, it returns nil.
func (server *Server) StartGrpcServer() error {
	log.Info().Str("ser_name", "broker").Msg("Starting gRPC server...")

	// listen on the specified address
	lis, err := net.Listen("tcp", server.config.BrokerAddress)
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "broker").Msgf("failed to listen: %s", err)
		return fmt.Errorf("failed to listen: %v", err)
	}

	// create a gRPC interceptor for logging using util.NewGrpcLoggerForService
	accessLogger := grpc.UnaryInterceptor(util.NewGrpcLoggerForService("broker"))

	// create a new gRPC server with the interceptor
	server.grpcServer = grpc.NewServer(accessLogger)

	// register access logger to the server
	pb.RegisterBrokerServiceServer(server.grpcServer, server)
	// register reflection service on gRPC server in order to able the user to explorer the service using grpcurl
	reflection.Register(server.grpcServer)

	// start the server and return the error if any
	return server.grpcServer.Serve(lis)
}

// Start dials destination gRPC server and starts the gRPC server for the Broker.
// it will block the current thread until the server is stopped.
// in case of an error, it returns the error and in case of peacefull shutdown, it returns nil.
func (server *Server) Start() error {
	// dial the destination service gRPC server
	err := server.DialDestinationRPC()
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "broker").Err(err).Msg("failed to dial destination")
		return err
	}

	// start gRPC server
	err = server.StartGrpcServer()
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "broker").Err(err).Msg("failed to listen")
	}
	return err
}

// Stop stops the gRPC server of the Broker.
// it will close connection to the destination service and stop the gRPC server.
func (server *Server) Stop() (err error) {
	defer func() {
		if recover() != nil {
			// server.destinationConn.Close()
			err = fmt.Errorf("failed to stop gRPC server peacefully")
		}
	}()
	log.Info().Str("ser_name", "broker").Msg("Stopping gRPC server...")
	server.cancelContext()
	server.grpcServer.Stop()
	err = server.destinationConn.Close()
	log.Info().Str("ser_name", "broker").Msg("Stopped gRPC server")
	return
}
