// package destination provides the implementation of the destination service
// it receives messages over gRPC and calculates total number of messages received and total number of bytes received
// and logs them and size of last received message to the main logger
package destination

import (
	"context"
	"fmt"
	"net"

	"github.com/SamMHD/simple-broker/pb"
	"github.com/SamMHD/simple-broker/util"
	"github.com/rs/zerolog/log"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

// Server is the gRPC server for the Destination service
// it contains configurations and implements the DestinationServiceServer interface which is generated by protoc.
type Server struct {
	ctx           context.Context    // context for the server
	cancelContext context.CancelFunc // cancel function for the context
	config        util.Config        // service configuration
	grpcServer    *grpc.Server       // gRPC server

	pb.UnimplementedDestinationServiceServer // required by the generated interface
}

// NewServer creates a new server object for the Destination service.
func NewServer(config util.Config) (*Server, error) {
	ctx, cancel := context.WithCancel(context.Background())

	// create a new server object
	server := &Server{
		config:        config,
		ctx:           ctx,
		cancelContext: cancel,
	}

	// return the server object
	return server, nil
}

// Start starts the gRPC server for the Destination service.
// it listens to the configured address and starts serving the gRPC requests.
// it will return an error if the server fails to start, otherwise it will block the thread
// and wait for the server to stop. in case of peacefull stop, it will return nil.
func (server *Server) Start() error {
	log.Info().Str("ser_name", "des_service").Msg("starting server...")

	// listen to the configured address
	lis, err := net.Listen("tcp", server.config.DestinationAddress)
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "des_service").Msgf("failed to listen: %v", err)
		return err
	}

	// create a gRPC interceptor for logging using util.NewGrpcLoggerForService
	accessLogger := grpc.UnaryInterceptor(util.NewGrpcLoggerForService("des_service"))

	// create a new gRPC server
	server.grpcServer = grpc.NewServer(accessLogger)

	// register access logger to the server
	pb.RegisterDestinationServiceServer(server.grpcServer, server)
	// register reflection service on gRPC server in order to able the user to explorer the service using grpcurl
	reflection.Register(server.grpcServer)

	// start the server and return the error if any
	err = server.grpcServer.Serve(lis)
	if err != nil {
		// if there is an error, log it using main logger and return
		log.Error().Str("ser_name", "des_service").Err(err).Msg("failed to listen")
	}
	return err
}

// Stop stops the gRPC server of the Destination service.
func (server *Server) Stop() (err error) {
	defer func() {
		if recover() != nil {
			err = fmt.Errorf("failed to stop gRPC server peacefully")
		}
	}()
	log.Info().Str("ser_name", "des_service").Msg("Stopping gRPC server...")
	server.cancelContext()
	server.grpcServer.Stop()
	log.Info().Str("ser_name", "des_service").Msg("Stopped gRPC server")
	return
}
